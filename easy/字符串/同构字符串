# 题目描述
# 给定两个字符串 s 和 t，判断它们是否是同构的。
# 如果s中的字符可以按某种映射关系替换得到t，那么这两个字符串是同构的。
# 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符
# 不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

# 个人想法
# 同构字符串长度一定相等，统计s,t分别统计一个字符连续出现的次数，比较是否相等
# 错了，回头好好想想

# 官方解法
# 哈希表
# 此题是「290. 单词规律」的简化版，需要我们判断s和t每个位置上的字符是否都一一对应，即s的任意一个字符被t中唯一的字符对应，同时 t的任意一个字符被s中
# 唯一的字符对应。这也被称为「双射」的关系。
# 以示例2为例，t中的字符a和r虽然有唯一的映射o，但对于s中的字符o来说其存在两个映射 {a,r}，故不满足条件。
# 因此，我们维护两张哈希表，第一张哈希表s2t 以s中字符为键，映射至t的字符为值，
# 第二张哈希表t2s 以t中字符为键，映射至s的字符为值。从左至右遍历两个字符串的字符，不断更新两张哈希表，
# 如果出现冲突index对应的字符s[index] 已经存在映射且不为t[index] 或当前下标index 对应的字符t[index] 已经存在映射且不为s[index]
# 时说明两个字符串无法构成同构，返回false。
# 如果遍历结束没有出现冲突，则表明两个字符串是同构的，返回true即可。

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:

        s2t = {}
        t2s = {}
        for i in range(len(s)):
            if (s2t.__contains__(s[i]) and s2t.get(s[i]) != t[i]) or (t2s.__contains__(t[i]) and t2s.get(t[i]) != s[i]):
                return False
            s2t[s[i]] = t[i]
            t2s[t[i]] = s[i]

        return True

# 时间复杂度: O(N), N为字符串的长度
# 空间复杂度：O(N)



